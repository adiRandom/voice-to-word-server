{"version":3,"sources":["models/Paragraph.ts","models/Page.ts","components/Homescreen/Homescreen.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Paragraph","state","Object","classCallCheck","this","underlyingText","text","localState","_text","trim","charAt","toUpperCase","slice","concat","Page","paragraphs","workingParagraph","size","length","createClass","key","value","newParagraph","localParagraphs","push","_this","filter","index","WorkingParagraphIndex","paragraph","get","_window","window","Homescreen","props","possibleConstructorReturn","getPrototypeOf","call","listener","remote","saveFile","toggleRecording","setState","prev","recording","start","stop","textRecived","workingPage","getWorkingParagraph","concatToParagraph","updateParagraph","changeCurrentParagraph","event","newPage","changeWorkingParagraph","target","createNewParagraph","addNewParagraph","deleteCurrentParagraph","deleteParagraph","clean","rec","webkitSpeechRecognition","SpeechRecognition","lang","continuous","onresult","results","resultIndex","transcript","_this2","react_default","a","createElement","id","map","className","onClick","onChange","val","React","Component","App","Homescreen_Homescreen_Homescreen","Boolean","location","hostname","match","ReactDOM","render","App_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.5700b8aa.chunk.js","sourcesContent":["/**\r\n * Imutable paragraph representaion\r\n */\r\n\r\nexport default class Paragraph {\r\n    private readonly underlyingText: string;\r\n\r\n    constructor(state: string) {\r\n        this.underlyingText = state\r\n    }\r\n\r\n    /**\r\n     * The text representation of the paragraph\r\n     */\r\n    get Paragraph(): string {\r\n        return this.underlyingText;\r\n    }\r\n\r\n    /**\r\n     * Concats some text to the paragraph\r\n     * @param text The text to concat to this paragraph\r\n     * @returns a new updated Paragraph\r\n     */\r\n\r\n    public concatToParagraph(text: string): Paragraph {\r\n        let localState = this.underlyingText;\r\n        if (this.underlyingText === \"\") {\r\n            const _text = text.trim();\r\n            localState = _text.charAt(0).toUpperCase() + _text.slice(1);\r\n        } else\r\n            localState = this.underlyingText.concat(text);\r\n\r\n        return new Paragraph(localState);\r\n    }\r\n\r\n    /**\r\n     * Clears the content of this Paragraph and replace it with a new one\r\n     * @param text The text to replace this Paragraph\r\n     * @returns a new updated Paragraph\r\n     */\r\n    public clearAndUpdateParagraph(text:string):Paragraph{\r\n        return new Paragraph(text);\r\n    }\r\n\r\n}","import Paragraph from \"./Paragraph\";\r\n\r\n/**\r\n * Immutable page representation\r\n */\r\nexport class Page {\r\n    /**\r\n     * The paragraphs contained by this page\r\n     */\r\n    private readonly paragraphs: Paragraph[];\r\n    /**\r\n     * The paragraph that is currently updating\r\n     */\r\n    private readonly workingParagraph: number;\r\n    /**\r\n     * How many paragraphs does this page contains\r\n     */\r\n    private readonly size: number;\r\n    constructor(paragraphs?: Paragraph[], workingParagraph?: number) {\r\n        this.paragraphs = paragraphs ? paragraphs : [new Paragraph(\"\")];\r\n        this.workingParagraph = workingParagraph ? workingParagraph : 0;\r\n        this.size = paragraphs ? paragraphs.length : 1;\r\n    }\r\n\r\n    /**\r\n     * @returns How many paragraphs does this page contains\r\n     */\r\n    get Size() { return this.size }\r\n\r\n\r\n    /**\r\n     * Get the index of the current working paragraph\r\n     */\r\n    get WorkingParagraphIndex() { return this.workingParagraph }\r\n\r\n    /**\r\n     * Get the paragraphs from this Page\r\n     */\r\n    get Paragraph(){return this.paragraphs}\r\n\r\n    /**\r\n     * @returns The paragraph that is being edited at the moment\r\n     */\r\n    public getWorkingParagraph(): Paragraph {\r\n        return this.paragraphs[this.workingParagraph];\r\n    }\r\n\r\n    /**\r\n     * Add a new paragraph to this page\r\n     * @Return a new updated page\r\n     */\r\n\r\n    public addNewParagraph(): Page {\r\n        const newParagraph = new Paragraph(\"\");\r\n        let localParagraphs = this.paragraphs;\r\n        localParagraphs.push(newParagraph);\r\n        return new Page(localParagraphs, localParagraphs.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Delete the currently working paragraph\r\n     * @Return a new updated page\r\n     */\r\n\r\n    public deleteParagraph(): Page {\r\n        let localParagraphs = this.paragraphs;\r\n\r\n        return new Page(localParagraphs.filter((value: Paragraph, index: number) => {\r\n            return index != this.WorkingParagraphIndex\r\n        }), this.workingParagraph - 1);\r\n    }\r\n\r\n\r\n    /**\r\n     * Updates the currently working paragraph\r\n     * @param paragrapf The paragraph to replace the currently woring paragraph\r\n     * @returns A new updated page\r\n     */\r\n\r\n    public updateParagraph(paragraph: Paragraph): Page {\r\n        const localState = this.paragraphs;\r\n        localState[this.workingParagraph] = paragraph;\r\n        return new Page(localState, this.workingParagraph);\r\n    }\r\n\r\n    /**\r\n     * Update which paragraph  is being woked on\r\n     * @param index The paragraph that the user wants to edit\r\n     * @returns A new updated Page\r\n     */\r\n\r\n    public changeWorkingParagraph(index: number): Page {\r\n        return index < this.size ? new Page(this.paragraphs, index) : this;\r\n    }\r\n\r\n}","import React from 'react'\r\n\r\nimport \"./Homescreen.css\";\r\nimport { Page } from '../../models/Page';\r\nimport Paragraph from '../../models/Paragraph';\r\n\r\nconst _window = window as any;\r\nexport default class Homescreen extends React.Component<{}, HomescreenState>{\r\n\r\n    constructor(props: Readonly<{}>) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            workingPage: new Page(),\r\n            recording: false,\r\n        }\r\n\r\n        //Get the recognition api\r\n        const rec = _window.webkitSpeechRecognition || _window.SpeechRecognition;\r\n\r\n        //Create an instance of SpeechRecognition\r\n        this.listener = new rec();\r\n\r\n        //Config the SpeechRecognition\r\n        this.listener.lang = \"ro-RO\";\r\n        this.listener.continuous = true;\r\n\r\n        this.listener.onresult = (event: any) => {\r\n            this.textRecived(event.results[event.resultIndex][0].transcript);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * The listener instance responsible of recording the spoken words and translating it into text\r\n     */\r\n    readonly listener: any;\r\n    readonly remote: any;\r\n    /**\r\n     * Save the input text to a docx\r\n     */\r\n    saveFile = () => {\r\n        //TODO: Make the server request\r\n    }\r\n\r\n    /**\r\n     * Toggle betwheen recording states\r\n     */\r\n\r\n    toggleRecording = () => {\r\n\r\n        this.setState((prev: HomescreenState) => ({\r\n            recording: !prev.recording\r\n        }), () => {\r\n            if (!this.state.recording) {\r\n                this.listener.stop()\r\n            } else {\r\n                this.listener.start();\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    /**\r\n     * Handle incoming text\r\n     * @param text The text recived\r\n     */\r\n    textRecived = (text: string) => {\r\n\r\n        //Get the paragraph in work\r\n        let workingParagraph = this.state.workingPage.getWorkingParagraph();\r\n\r\n        //Update it\r\n        workingParagraph = workingParagraph.concatToParagraph(text);\r\n\r\n        //And set the new state\r\n        this.setState((prev: HomescreenState) => ({\r\n            workingPage: prev.workingPage.updateParagraph(workingParagraph)\r\n        }))\r\n    }\r\n\r\n\r\n    /**\r\n     * Change the paragraph that is being worked on\r\n     */\r\n    changeCurrentParagraph = (event: any) => {\r\n        const newPage = this.state.workingPage.changeWorkingParagraph(event.target.value - 1);\r\n        this.setState({\r\n            workingPage: newPage\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add a new paragraph to the currently working page\r\n     */\r\n    createNewParagraph = () => {\r\n        const newPage = this.state.workingPage.addNewParagraph();\r\n        this.setState({\r\n            workingPage: newPage\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Deletes the currently working paragraph\r\n     */\r\n    deleteCurrentParagraph = () => {\r\n        const newPage = this.state.workingPage.deleteParagraph();\r\n        this.setState({\r\n            workingPage: newPage\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Clean the document\r\n     */\r\n    clean = () => {\r\n        this.setState({\r\n            workingPage: new Page()\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <main id='homescreen-container'>\r\n                {/* TODO: Add maxLength after deciding on a font size */}\r\n                {/* TODO: Replace with a div with children */}\r\n                <div id=\"recording-display\">\r\n                    {this.state.workingPage.Paragraph.map((value: Paragraph, index) =>\r\n                        (<div className=\"paragraph\" key={index}>{value.Paragraph}</div>)\r\n                    )}\r\n                </div>\r\n                <div className=\"button-duo\">\r\n                    <button className=\"button\" onClick={this.toggleRecording}>{!this.state.recording ? \"Înregistrează\" : \"Stop\"}</button>\r\n                    <button className=\"button\" onClick={this.clean}>Curăță</button>\r\n                </div>\r\n                <h5>Paragraful curent</h5>\r\n                <select id=\"current-paragraph\" value={this.state.workingPage.WorkingParagraphIndex + 1} onChange={(event) => this.changeCurrentParagraph(event)}>\r\n                    {this.state.workingPage.Paragraph.map((val, index) => (\r\n                        <option key={index} value={index + 1}>{index + 1}</option>\r\n                    ))}\r\n                </select>\r\n\r\n                <button className=\"button\" onClick={this.createNewParagraph}>Adaugă un paragraf</button>\r\n                <button className=\"button\" onClick={this.deleteCurrentParagraph}>Șterge paragraful curent</button>\r\n                <button className=\"button\" onClick={this.saveFile}>Salvează</button>\r\n            </main>\r\n        )\r\n    }\r\n}\r\n\r\ninterface HomescreenState {\r\n    /**\r\n     * The page that is being worked in\r\n     */\r\n    workingPage: Page\r\n    /**\r\n     * Whether or not the app is currently recording\r\n     */\r\n    recording: boolean,\r\n\r\n\r\n}","import React from \"react\";\nimport { Route } from \"react-router\";\nimport Homescreen from \"./components/Homescreen/Homescreen\";\n\nexport default class App extends React.Component<{}, {}>{\n  render() {\n    return (\n      <Homescreen></Homescreen>\n    )\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n        <App />,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}